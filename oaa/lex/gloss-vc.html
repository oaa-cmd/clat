<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>kmp+</title>
  <style>
    :root {
      --primary: #325980;
      --secondary: #3498db;
      --light-gray: #f5f5f5;
      --lighter-gray: #f1f1f1;
      --white: #ffffff;

      --bg: var(--light-gray);
      --text: var(--primary);
      --card-bg: var(--white);
    }

    body.dark {
      --bg: #1e1e1e;
      --text: #f0f0f0;
      --card-bg: #2c2c2c;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--bg);
      color: var(--text);
    }

    header {
      background-color: var(--primary);
      color: var(--white);
      padding: 20px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: relative;
    }

    #theme-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--white);
    }

    .container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 0 20px;
    }

    .language-selector {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      gap: 10px;
    }

    .language-btn {
      padding: 10px 15px;
      background-color: var(--card-bg);
      border: 2px solid var(--secondary);
      color: var(--text);
      cursor: pointer;
      border-radius: 5px;
      font-weight: bold;
      transition: all 0.3s;
    }

    .language-btn.active {
      background-color: var(--secondary);
      color: var(--white);
    }

    .glossary {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
    }

    .term-card {
      background-color: var(--card-bg);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      transition: transform 0.3s;
    }

    .term-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .term-card h3 {
      color: var(--secondary);
      margin-bottom: 10px;
      border-bottom: 2px solid var(--lighter-gray);
      padding-bottom: 5px;
    }

    .term-card p {
      color: var(--text);
      line-height: 1.5;
    }

    .add-term-btn {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: var(--secondary);
      color: var(--white);
      border: none;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }

    .add-term-btn:hover {
      background-color: var(--primary);
      transform: scale(1.05);
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background-color: var(--card-bg);
      color: var(--text);
      padding: 30px;
      border-radius: 10px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .close-modal {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text);
    }

    
	
	.form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: var(--text);
            font-weight: bold;
        }

    input, textarea, select {
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid #ccc;
	  width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
    }
	

    .submit-btn {
      background-color: var(--secondary);
      color: var(--white);
      border: none;
      padding: 12px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s;
    }

    .submit-btn:hover {
      background-color: var(--primary);
    }

    .search-container {
      margin-bottom: 20px;
    }

    .search-input {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--lighter-gray);
      border-radius: 30px;
      font-size: 16px;
      transition: all 0.3s;
      background-color: var(--card-bg);
      color: var(--text);
    }

    .search-input:focus {
      border-color: var(--secondary);
      outline: none;
    }

    @media (max-width: 768px) {
      .glossary {
        grid-template-columns: 1fr;
      }

      .language-selector {
        flex-wrap: wrap;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Vibe Coding Glossary</h1>
    <p>Multilingual Dictionary for the New Programming Paradigm</p>
    <button id="theme-toggle" title="Toggle theme">üåô</button>
  </header>

  <div class="container">
    
    <div class="container">
        <div class="language-selector">
            <button class="language-btn active" data-lang="en">English</button>
            <button class="language-btn" data-lang="ru">–†—É—Å—Å–∫–∏–π</button>
            <button class="language-btn" data-lang="de">Deutsch</button>
            <button class="language-btn" data-lang="zh">‰∏≠Êñá</button>
        </div>
        
        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search terms...">
        </div>
        
        <div class="glossary" id="glossary-container">
            <!-- Terms will be inserted here dynamically -->
        </div>
    </div>
    
    <button class="add-term-btn" id="add-term-btn">+</button>
    
    <div class="modal" id="add-term-modal">
        <div class="modal-content">
            <div class="modal-header">
			<h2>Add New Term</h2>
            <button class="close-modal" id="close-modal">&times;</button>
        </div>
        
        <form id="add-term-form">
            <div class="form-group">
                <label for="term-en">Term (English):</label>
                <input type="text" id="term-en" required>
            </div>
            
            <div class="form-group">
                <label for="definition-en">Definition (English):</label>
                <textarea id="definition-en" required></textarea>
            </div>
            
            <div class="form-group">
                <label for="term-ru">Term (Russian):</label>
                <input type="text" id="term-ru" required>
            </div>
            
            <div class="form-group">
                <label for="definition-ru">Definition (Russian):</label>
                <textarea id="definition-ru" required></textarea>
            </div>
            
            <div class="form-group">
                <label for="term-de">Term (German):</label>
                <input type="text" id="term-de" required>
            </div>
            
            <div class="form-group">
                <label for="definition-de">Definition (German):</label>
                <textarea id="definition-de" required></textarea>
            </div>
            
            <div class="form-group">
                <label for="term-zh">Term (Chinese):</label>
                <input type="text" id="term-zh" required>
            </div>
            
            <div class="form-group">
                <label for="definition-zh">Definition (Chinese):</label>
                <textarea id="definition-zh" required></textarea>
            </div>
            
            <button type="submit" class="submit-btn">Add Term</button>
        </form>
    </div>
</div>

<script>
    // Initial glossary data
    const glossaryData = [
        {
            id: 1,
            en: {
                term: "Vibe Coding",
                definition: "An approach to programming based on intuitive interaction with language models instead of traditional code writing."
            },
            ru: {
                term: "Vibe Coding",
                definition: "–ü–æ–¥—Ö–æ–¥ –∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ —Å —è–∑—ã–∫–æ–≤—ã–º–∏ –º–æ–¥–µ–ª—è–º–∏ –≤–º–µ—Å—Ç–æ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞."
            },
            de: {
                term: "Vibe Coding",
                definition: "Ein Programmieransatz, der auf der intuitiven Interaktion mit Sprachmodellen basiert, anstatt auf traditionellem Schreiben von Code."
            },
            zh: {
                term: "Ê∞õÂõ¥ÁºñÁ®ã",
                definition: "‰∏ÄÁßçÂü∫‰∫é‰∏éËØ≠Ë®ÄÊ®°ÂûãÁõ¥Ëßâ‰∫§‰∫íËÄåÈùû‰º†Áªü‰ª£Á†ÅÁºñÂÜôÁöÑÁºñÁ®ãÊñπÊ≥ï„ÄÇ"
            }
        },
        {
            id: 2,
            en: {
                term: "Prompt Engineering",
                definition: "The art of crafting requests to LLMs to obtain the desired code output."
            },
            ru: {
                term: "Prompt Engineering",
                definition: "–ò—Å–∫—É—Å—Å—Ç–≤–æ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ LLM –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∂–µ–ª–∞–µ–º–æ–≥–æ –∫–æ–¥–∞."
            },
            de: {
                term: "Prompt-Engineering",
                definition: "Die Kunst, Anfragen an LLMs zu formulieren, um den gew√ºnschten Code zu erhalten."
            },
            zh: {
                term: "ÊèêÁ§∫Â∑•Á®ã",
                definition: "Á≤æÂøÉËÆæËÆ°ÂêëÂ§ßËØ≠Ë®ÄÊ®°ÂûãÊèêÂá∫ËØ∑Ê±Ç‰ª•Ëé∑ÂæóÊâÄÈúÄ‰ª£Á†ÅÁöÑËâ∫ÊúØ„ÄÇ"
            }
        },
        {
            id: 3,
            en: {
                term: "Intention-to-Code",
                definition: "The process of transforming an idea or intention into working code through LLM."
            },
            ru: {
                term: "Intention-to-Code",
                definition: "–ü—Ä–æ—Ü–µ—Å—Å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–¥–µ–∏ –∏–ª–∏ –Ω–∞–º–µ—Ä–µ–Ω–∏—è –≤ —Ä–∞–±–æ—á–∏–π –∫–æ–¥ —á–µ—Ä–µ–∑ LLM."
            },
            de: {
                term: "Intention-zu-Code",
                definition: "Der Prozess der Umwandlung einer Idee oder Absicht in funktionierenden Code durch LLM."
            },
            zh: {
                term: "ÊÑèÂõæËΩ¨‰ª£Á†Å",
                definition: "ÈÄöËøáÂ§ßËØ≠Ë®ÄÊ®°ÂûãÂ∞ÜÊÉ≥Ê≥ïÊàñÊÑèÂõæËΩ¨Âåñ‰∏∫ÂèØÂ∑•‰Ωú‰ª£Á†ÅÁöÑËøáÁ®ã„ÄÇ"
            }
        },
        {
            id: 4,
            en: {
                term: "Vibes",
                definition: "Intuitive understanding of what the code should do without the need to formalize the algorithm."
            },
            ru: {
                term: "Vibes",
                definition: "–ò–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ —Ç–æ–≥–æ, —á—Ç–æ –¥–æ–ª–∂–µ–Ω –¥–µ–ª–∞—Ç—å –∫–æ–¥, –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ñ–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞."
            },
            de: {
                term: "Vibes",
                definition: "Intuitives Verst√§ndnis dessen, was der Code tun soll, ohne die Notwendigkeit, den Algorithmus zu formalisieren."
            },
            zh: {
                term: "Ê∞õÂõ¥ÊÑü",
                definition: "ÂØπ‰ª£Á†ÅÂ∫îËØ•ÂÅö‰ªÄ‰πàÁöÑÁõ¥ËßâÁêÜËß£ÔºåÊó†ÈúÄÂΩ¢ÂºèÂåñÁÆóÊ≥ï„ÄÇ"
            }
        },
        {
            id: 5,
            en: {
                term: "Flow State Programming",
                definition: "A state where the programmer and LLM are in a productive dialogue."
            },
            ru: {
                term: "Flow State Programming",
                definition: "–°–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç –∏ LLM –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ–º –¥–∏–∞–ª–æ–≥–µ."
            },
            de: {
                term: "Flow-Zustand-Programmierung",
                definition: "Ein Zustand, in dem sich Programmierer und LLM in einem produktiven Dialog befinden."
            },
            zh: {
                term: "ÂøÉÊµÅÁºñÁ®ãÁä∂ÊÄÅ",
                definition: "Á®ãÂ∫èÂëò‰∏éÂ§ßËØ≠Ë®ÄÊ®°ÂûãÂ§Ñ‰∫éÂØåÊúâÊàêÊïàÁöÑÂØπËØùÁä∂ÊÄÅ„ÄÇ"
            }
        },
        {
            id: 6,
            en: {
                term: "Semantic Debugging",
                definition: "Fixing errors by explaining the problem to LLM in natural language."
            },
            ru: {
                term: "Semantic Debugging",
                definition: "–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ —á–µ—Ä–µ–∑ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã LLM –Ω–∞ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º —è–∑—ã–∫–µ."
            },
            de: {
                term: "Semantisches Debugging",
                definition: "Beheben von Fehlern durch Erkl√§ren des Problems f√ºr LLM in nat√ºrlicher Sprache."
            },
            zh: {
                term: "ËØ≠‰πâË∞ÉËØï",
                definition: "ÈÄöËøáÁî®Ëá™ÁÑ∂ËØ≠Ë®ÄÂêëÂ§ßËØ≠Ë®ÄÊ®°ÂûãËß£ÈáäÈóÆÈ¢òÊù•‰øÆÂ§çÈîôËØØ„ÄÇ"
            }
        },
        {
            id: 7,
            en: {
                term: "Code Whispering",
                definition: "Fine-tuning requests to get exactly the code you need."
            },
            ru: {
                term: "Code Whispering",
                definition: "–¢–æ–Ω–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–º–µ–Ω–Ω–æ —Ç–æ–≥–æ –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–µ–Ω."
            },
            de: {
                term: "Code-Fl√ºstern",
                definition: "Feinabstimmung von Anfragen, um genau den Code zu erhalten, den man ben√∂tigt."
            },
            zh: {
                term: "‰ª£Á†Å‰ΩéËØ≠",
                definition: "ÂæÆË∞ÉËØ∑Ê±Ç‰ª•Ëé∑ÂæóÊÅ∞Â•ΩÈúÄË¶ÅÁöÑ‰ª£Á†Å„ÄÇ"
            }
        },
        {
            id: 8,
            en: {
                term: "Context Sculpting",				
				definition: "The art of shaping and maintaining conversation context with LLM for complex projects."
                },
                ru: {
                    term: "Context Sculpting",
                    definition: "–ò—Å–∫—É—Å—Å—Ç–≤–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –±–µ—Å–µ–¥—ã —Å LLM –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤."
                },
                de: {
                    term: "Kontext-Modellierung",
                    definition: "Die Kunst, den Gespr√§chskontext mit LLM f√ºr komplexe Projekte zu gestalten und aufrechtzuerhalten."
                },
                zh: {
                    term: "‰∏ä‰∏ãÊñáÂ°ëÈÄ†",
                    definition: "‰∏∫Â§çÊùÇÈ°πÁõÆÂ°ëÈÄ†ÂíåÁª¥Êä§‰∏éÂ§ßËØ≠Ë®ÄÊ®°ÂûãÂØπËØù‰∏ä‰∏ãÊñáÁöÑËâ∫ÊúØ„ÄÇ"
                }
            },
            {
                id: 9,
                en: {
                    term: "Vibe Check",
                    definition: "Verifying that the generated code matches the original intent."
                },
                ru: {
                    term: "Vibe Check",
                    definition: "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ–º—É –∑–∞–º—ã—Å–ª—É."
                },
                de: {
                    term: "Vibe-Pr√ºfung",
                    definition: "√úberpr√ºfung, ob der generierte Code der urspr√ºnglichen Absicht entspricht."
                },
                zh: {
                    term: "Ê∞õÂõ¥Ê£ÄÊü•",
                    definition: "È™åËØÅÁîüÊàêÁöÑ‰ª£Á†ÅÊòØÂê¶Á¨¶ÂêàÂéüÂßãÊÑèÂõæ„ÄÇ"
                }
            },
            {
                id: 10,
                en: {
                    term: "Intuitive Refactoring",
                    definition: "Improving code through dialogue with LLM without deep diving into technical details."
                },
                ru: {
                    term: "Intuitive Refactoring",
                    definition: "–£–ª—É—á—à–µ–Ω–∏–µ –∫–æ–¥–∞ —á–µ—Ä–µ–∑ –¥–∏–∞–ª–æ–≥ —Å LLM –±–µ–∑ –≥–ª—É–±–æ–∫–æ–≥–æ –ø–æ–≥—Ä—É–∂–µ–Ω–∏—è –≤ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏."
                },
                de: {
                    term: "Intuitives Refactoring",
                    definition: "Verbesserung des Codes durch Dialog mit LLM ohne tiefes Eintauchen in technische Details."
                },
                zh: {
                    term: "Áõ¥ËßâÈáçÊûÑ",
                    definition: "ÈÄöËøá‰∏éÂ§ßËØ≠Ë®ÄÊ®°ÂûãÂØπËØùÊîπËøõ‰ª£Á†ÅÔºåÊó†ÈúÄÊ∑±ÂÖ•ÊäÄÊúØÁªÜËäÇ„ÄÇ"
                }
            }
        ];
        
        // Current selected language
        let currentLanguage = 'en';
        
        // DOM elements
        const glossaryContainer = document.getElementById('glossary-container');
        const languageButtons = document.querySelectorAll('.language-btn');
        const searchInput = document.querySelector('.search-input');
        const addTermBtn = document.getElementById('add-term-btn');
        const addTermModal = document.getElementById('add-term-modal');
        const closeModalBtn = document.getElementById('close-modal');
        const addTermForm = document.getElementById('add-term-form');
        
        // Function to render the glossary
        function renderGlossary(data = glossaryData, language = currentLanguage) {
            glossaryContainer.innerHTML = '';
            
            data.forEach(item => {
                const termCard = document.createElement('div');
                termCard.className = 'term-card';
                
                const term = document.createElement('h3');
                term.textContent = item[language].term;
                
                const definition = document.createElement('p');
                definition.textContent = item[language].definition;
                
                termCard.appendChild(term);
                termCard.appendChild(definition);
                
                glossaryContainer.appendChild(termCard);
            });
        }
        
        // Function to filter glossary by search term
        function filterGlossary(searchTerm) {
            const filtered = glossaryData.filter(item => {
                const term = item[currentLanguage].term.toLowerCase();
                const definition = item[currentLanguage].definition.toLowerCase();
                return term.includes(searchTerm) || definition.includes(searchTerm);
            });
            
            renderGlossary(filtered);
        }
        
        // Function to add a new term
        function addNewTerm(event) {
            event.preventDefault();
            
            const newTerm = {
                id: glossaryData.length + 1,
                en: {
                    term: document.getElementById('term-en').value,
                    definition: document.getElementById('definition-en').value
                },
                ru: {
                    term: document.getElementById('term-ru').value,
                    definition: document.getElementById('definition-ru').value
                },
                de: {
                    term: document.getElementById('term-de').value,
                    definition: document.getElementById('definition-de').value
                },
                zh: {
                    term: document.getElementById('term-zh').value,
                    definition: document.getElementById('definition-zh').value
                }
            };
            
            glossaryData.push(newTerm);
            renderGlossary();
            addTermModal.style.display = 'none';
            addTermForm.reset();
        }
        
        // Event listeners
        languageButtons.forEach(button => {
            button.addEventListener('click', () => {
                languageButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentLanguage = button.getAttribute('data-lang');
                renderGlossary();
                
                // Update search placeholder
                const placeholders = {
                    'en': 'Search terms...',
                    'ru': '–ü–æ–∏—Å–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤...',
                    'de': 'Begriffe suchen...',
                    'zh': 'ÊêúÁ¥¢ÊúØËØ≠...'
                };
                searchInput.placeholder = placeholders[currentLanguage];
            });
        });
        
        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterGlossary(searchTerm);
        });
        
        addTermBtn.addEventListener('click', () => {
            addTermModal.style.display = 'flex';
        });
        
        closeModalBtn.addEventListener('click', () => {
            addTermModal.style.display = 'none';
            addTermForm.reset();
        });
        
        addTermForm.addEventListener('submit', addNewTerm);
        
        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === addTermModal) {
                addTermModal.style.display = 'none';
                addTermForm.reset();
            }
        });
        
        // Initial render
        renderGlossary();
		
		 const themeToggle = document.getElementById('theme-toggle');
    const body = document.body;

    // Apply saved theme on load
    if (localStorage.getItem('theme') === 'dark') {
      body.classList.add('dark');
      themeToggle.textContent = '‚òÄÔ∏è';
    }

    themeToggle.addEventListener('click', () => {
      body.classList.toggle('dark');
      const isDark = body.classList.contains('dark');
      themeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
    });
    </script>
</body>
</html>