<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Стохастический Словарь ИИ</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
	<script src="d3.v7.min.js"></script>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6f94c6;
            --bg-color: #f5f7fa;
            --text-color: #333;
            --card-bg: #fff;
            --border-color: #ddd;
            --highlight-color: #e6eef8;
            --graph-node-color: #4a6fa5;
            --graph-link-color: #aaa;
			 --primary-color: #3e76ad;
		--header-text-color: #ffffff;
		--border-radius: 8px;
        }

        [data-theme="dark"] {
            --primary-color: #5d8bd1;
            --secondary-color: #7aa0d4;
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --card-bg: #2a2a2a;
            --border-color: #444;
            --highlight-color: #3a3a3a;
            --graph-node-color: #7aa0d4;
            --graph-link-color: #666;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            transition: background-color 0.3s, color 0.3s;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
    display: flex; /* Используем flexbox */
    justify-content: space-between; /* Размещаем элементы по краям */
    align-items: center; /* Выравниваем элементы по вертикали */
    background-color: var(--primary-color);
    color: var(--header-text-color);
    padding: 20px 20px; /* Добавляем отступы по бокам */
    border-radius: var(--border-radius);
    margin-bottom: 20px;
    background-image: linear-gradient(135deg, var(--primary-color) 0%, #2c3e50 100%);
}

h1 {
    font-size: 2.2rem;
    margin: 0; /* Убираем отступы, чтобы лучше выровнять заголовок */
}

        .theme-toggle {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--primary-color);
        }

        .info-button, .search-button, .random-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-left: 10px;
            transition: background-color 0.3s;
        }

        .info-button:hover, .search-button:hover, .random-button:hover {
            background-color: var(--secondary-color);
        }

        .welcome-container, .info-container, .search-container, .result-container {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
        }

        .search-form {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            min-width: 200px;
            background-color: var(--card-bg);
            color: var(--text-color);
        }

        .term-title {
            font-size: 1.8rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .definitions, .connections {
            margin-bottom: 30px;
        }

        .definition {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--highlight-color);
            border-radius: 6px;
        }

        .probability-bar {
            height: 15px;
            background-color: var(--secondary-color);
            border-radius: 10px;
            margin: 10px 0;
        }

        .probability-label {
            font-weight: bold;
            color: var(--primary-color);
        }

        .example {
            font-style: italic;
            margin-top: 10px;
            padding-left: 15px;
            border-left: 3px solid var(--secondary-color);
        }

        .graph-container {
            width: 100%;
            height: 300px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            background-color: var(--highlight-color);
        }

        .welcome-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .welcome-form input {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            background-color: var(--card-bg);
            color: var(--text-color);
        }

        .welcome-form button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
        }

        .welcome-form button:hover {
            background-color: var(--secondary-color);
        }

        .hidden {
            display: none;
        }

        .back-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 10px;
            transition: background-color 0.3s;
        }

        .back-button:hover {
            background-color: var(--secondary-color);
        }

        @media (max-width: 768px) {
            .search-form {
                flex-direction: column;
            }
            
            .search-input {
                width: 100%;
            }
            
            .search-buttons {
                display: flex;
                gap: 10px;
            }
            
            .info-button, .search-button, .random-button {
                margin-left: 0;
                flex: 1;
            }
            
            h1 {
                font-size: 1.5rem;
            }
        }
		
		ul {
    padding-left: 20px; /* Увеличивает отступ внутри списка */
}

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Стохастический Словарь ИИ</h1>
            <button class="theme-toggle" id="themeToggle">☀️</button>
        </header>

        <!-- Форма приветствия для ввода данных студента -->
        <div class="welcome-container" id="welcomeContainer">
            <h2>Добро пожаловать в Стохастический Словарь ИИ</h2>
            <p>Пожалуйста, представьтесь для персонализации контента:</p>
            <form class="welcome-form" id="welcomeForm">
                <input type="text" id="userName" placeholder="Фамилия Имя" required>
                <button type="submit">Начать работу</button>
            </form>
        </div>

        <!-- Информационный блок о приложении -->
        <div class="info-container hidden" id="infoContainer">
            <h2>О приложении</h2>
            <div id="infoContent"></div>
            <button class="back-button" id="infoBackButton">Назад</button>
        </div>

        <!-- Основной интерфейс поиска -->
        <div class="search-container hidden" id="searchContainer">
            <form class="search-form" id="searchForm">
                <input type="text" id="searchInput" class="search-input" placeholder="Введите термин..." list="termsDatalist">
                <datalist id="termsDatalist"></datalist>
                <div class="search-buttons">
                    <button type="submit" class="search-button">Найти</button>
                    <button type="button" class="random-button" id="randomButton">Случайный термин</button>
                    <button type="button" class="info-button" id="infoButton">О приложении</button>
                </div>
            </form>
        </div>

        <!-- Контейнер для отображения результатов -->
        <div class="result-container hidden" id="resultContainer">
            <h2 class="term-title" id="termTitle"></h2>
            
            <div class="definitions">
                <h3>Вероятностные дефиниции</h3>
                <div id="definitionsContainer"></div>
            </div>
            
            <div class="connections">
                <h3>Семантические связи</h3>
                <p><small>Толщина линий отражает силу связи</small></p>
                <div class="graph-container" id="graphContainer"></div>
            </div>
        </div>
    </div>

    <script>
        // Предзаданный словарь терминов
        const dictionary = {
            "Стохастичность": {
                definitions: [
                    {
                        text: "Свойство системы, при котором её поведение определяется случайными факторами и может быть описано лишь в терминах вероятности.",
                        probability: 0.85,
                        examples: ["В языковых моделях ИИ стохастичность проявляется в том, что на один и тот же запрос система может генерировать разные ответы."]
                    },
                    {
                        text: "В контексте ИИ и обработки естественного языка — метод генерации текста с элементом случайности для повышения разнообразия и креативности выходных данных.",
                        probability: 0.65,
                        examples: ["При использовании параметра temperature в языковой модели мы контролируем степень стохастичности ответов."]
                    },
                    {
                        text: "Математическая концепция, описывающая процессы, результат которых зависит от случайных факторов и может быть предсказан только с определенной вероятностью.",
                        probability: 0.75,
                        examples: ["Стохастический подход к моделированию языка позволяет создавать более естественные тексты."]
                    }
                ],
                connections: [
                    { word: "Вероятность", type: "связанное понятие", weight: 0.9 },
                    { word: "Нейронная сеть", type: "применение", weight: 0.6 },
                    { word: "Контекст", type: "зависимость", weight: 0.5 },
                    { word: "Эмбеддинг", type: "компонент", weight: 0.4 }
                ]
            },
            "Эмбеддинг": {
                definitions: [
                    {
                        text: "Представление слов, фраз или других языковых единиц в виде векторов в многомерном пространстве, где семантически близкие понятия располагаются ближе друг к другу.",
                        probability: 0.9,
                        examples: ["Word2Vec — это один из популярных методов создания эмбеддингов слов на основе контекста их употребления."]
                    },
                    {
                        text: "Метод преобразования категориальных данных в числовые векторы, сохраняющий семантические отношения между элементами.",
                        probability: 0.7,
                        examples: ["В модели BERT эмбеддинги создаются для каждого токена с учетом контекста всего предложения."]
                    },
                    {
                        text: "Отображение объектов (слов, предложений, документов) в точки векторного пространства таким образом, чтобы сохранить их взаимоотношения и семантические свойства.",
                        probability: 0.8,
                        examples: ["Используя эмбеддинги, мы можем вычислять семантическое сходство между словами через косинусное расстояние между их векторами."]
                    }
                ],
                connections: [
                    { word: "Нейронная сеть", type: "технология", weight: 0.8 },
                    { word: "Контекст", type: "зависимость", weight: 0.9 },
                    { word: "Стохастичность", type: "свойство", weight: 0.4 },
                    { word: "Вероятность", type: "компонент", weight: 0.5 }
                ]
            },
            "Вероятность": {
                definitions: [
                    {
                        text: "Численная мера возможности появления какого-либо события в определённых условиях, которые могут повторяться неограниченное число раз.",
                        probability: 0.9,
                        examples: ["В языковых моделях вероятность следующего слова зависит от предыдущих слов в последовательности."]
                    },
                    {
                        text: "В контексте обработки естественного языка — оценка шансов появления определенного слова или фразы в данном контексте.",
                        probability: 0.75,
                        examples: ["Для предсказания следующего слова языковая модель оценивает вероятности всех слов в словаре и выбирает наиболее вероятное."]
                    },
                    {
                        text: "Количественная характеристика степени уверенности в истинности утверждения или возникновения события в условиях неопределенности.",
                        probability: 0.65,
                        examples: ["Системы машинного перевода присваивают вероятности различным вариантам перевода и выбирают оптимальный."]
                    }
                ],
                connections: [
                    { word: "Стохастичность", type: "основа", weight: 0.9 },
                    { word: "Контекст", type: "влияние", weight: 0.7 },
                    { word: "Нейронная сеть", type: "применение", weight: 0.8 },
                    { word: "Эмбеддинг", type: "компонент", weight: 0.5 }
                ]
            },
            "Контекст": {
                definitions: [
                    {
                        text: "Языковое окружение, влияющее на интерпретацию слова или фразы и определяющее его смысловые оттенки.",
                        probability: 0.85,
                        examples: ["Слово 'ключ' может означать инструмент для открывания замка или источник воды, в зависимости от контекста."]
                    },
                    {
                        text: "В нейронных языковых моделях — набор слов, предшествующих и/или следующих за целевым словом, используемый для определения вероятностного распределения значений этого слова.",
                        probability: 0.75,
                        examples: ["Модели типа BERT используют двунаправленный контекст, учитывая слова как до, так и после анализируемого слова."]
                    },
                    {
                        text: "Информация о ситуации, обстановке, условиях, в которых происходит общение и которые влияют на понимание высказывания.",
                        probability: 0.7,
                        examples: ["При анализе текста важно учитывать не только лингвистический контекст, но и социально-культурный."]
                    }
                ],
                connections: [
                    { word: "Эмбеддинг", type: "зависимость", weight: 0.9 },
                    { word: "Вероятность", type: "влияние", weight: 0.8 },
                    { word: "Стохастичность", type: "свойство", weight: 0.5 },
                    { word: "Нейронная сеть", type: "применение", weight: 0.7 }
                ]
            },
            "Нейронная сеть": {
                definitions: [
                    {
                        text: "Математическая модель, построенная по принципу организации и функционирования биологических нейронных сетей, способная к обучению на основе данных.",
                        probability: 0.9,
                        examples: ["Глубокие нейронные сети с множеством слоев используются для создания современных языковых моделей."]
                    },
                    {
                        text: "В контексте обработки естественного языка — система взаимосвязанных искусственных нейронов, используемая для распознавания закономерностей в языковых данных.",
                        probability: 0.8,
                        examples: ["Рекуррентные нейронные сети особенно эффективны для обработки последовательностей, таких как предложения."]
                    },
                    {
                        text: "Вычислительная система, состоящая из множества простых взаимодействующих элементов (нейронов), которая обрабатывает информацию, реагируя на внешние воздействия.",
                        probability: 0.75,
                        examples: ["Трансформеры — это тип нейронных сетей, основанный на механизме внимания, революционизировавший NLP."]
                    }
                ],
                connections: [
                    { word: "Эмбеддинг", type: "компонент", weight: 0.8 },
                    { word: "Стохастичность", type: "свойство", weight: 0.6 },
                    { word: "Вероятность", type: "механизм", weight: 0.8 },
                    { word: "Контекст", type: "обработка", weight: 0.7 }
                ]
            }
        };

        // Основные переменные и состояние приложения
        let userData = {
            name: ""
        };
        let currentTheme = "light";

        // DOM-элементы
        const welcomeContainer = document.getElementById('welcomeContainer');
        const welcomeForm = document.getElementById('welcomeForm');
        const userNameInput = document.getElementById('userName');
        const searchContainer = document.getElementById('searchContainer');
        const searchForm = document.getElementById('searchForm');
        const searchInput = document.getElementById('searchInput');
        const termsDatalist = document.getElementById('termsDatalist');
        const randomButton = document.getElementById('randomButton');
        const infoButton = document.getElementById('infoButton');
        const infoContainer = document.getElementById('infoContainer');
        const infoContent = document.getElementById('infoContent');
        const infoBackButton = document.getElementById('infoBackButton');
        const resultContainer = document.getElementById('resultContainer');
        const termTitle = document.getElementById('termTitle');
        const definitionsContainer = document.getElementById('definitionsContainer');
        const graphContainer = document.getElementById('graphContainer');
        const themeToggle = document.getElementById('themeToggle');

        // Инициализация приложения
        function initApp() {
            // Проверяем, есть ли сохраненные данные пользователя
            const savedUserData = localStorage.getItem('stochasticDictionaryUserData');
            if (savedUserData) {
                userData = JSON.parse(savedUserData);
                showSearchInterface();
            } else {
                showWelcomeForm();
            }

            // Заполняем datalist доступными терминами
            populateDatalist();

            // Устанавливаем обработчики событий
            setupEventListeners();

            // Проверяем сохраненную тему
            const savedTheme = localStorage.getItem('stochasticDictionaryTheme');
            if (savedTheme) {
                currentTheme = savedTheme;
                applyTheme(currentTheme);
            }
        }

        // Заполнение datalist для автодополнения
        function populateDatalist() {
            termsDatalist.innerHTML = '';
            Object.keys(dictionary).forEach(term => {
                const option = document.createElement('option');
                option.value = term;
                termsDatalist.appendChild(option);
            });
        }

        // Настройка обработчиков событий
        function setupEventListeners() {
            // Форма приветствия
            welcomeForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const nameValue = userNameInput.value.trim();
                if (nameValue) {
                    userData.name = nameValue;
                    localStorage.setItem('stochasticDictionaryUserData', JSON.stringify(userData));
                    showSearchInterface();
                }
            });

            // Форма поиска
            searchForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const searchTerm = searchInput.value.trim();
                if (searchTerm && dictionary[searchTerm]) {
                    displayTermInfo(searchTerm);
                } else {
                    alert('Термин не найден в словаре');
                }
            });

            // Кнопка случайного термина
            randomButton.addEventListener('click', () => {
                const terms = Object.keys(dictionary);
                const randomTerm = terms[Math.floor(Math.random() * terms.length)];
                searchInput.value = randomTerm;
                displayTermInfo(randomTerm);
            });

            // Кнопка информации о приложении
            infoButton.addEventListener('click', showInfoSection);

            // Кнопка возврата из информационного раздела
            infoBackButton.addEventListener('click', () => {
                infoContainer.classList.add('hidden');
                searchContainer.classList.remove('hidden');
                if (!resultContainer.classList.contains('hidden')) {
                    resultContainer.classList.remove('hidden');
                }
            });

            // Переключатель темы
            themeToggle.addEventListener('click', toggleTheme);
        }

        // Отображение формы приветствия
        function showWelcomeForm() {
            welcomeContainer.classList.remove('hidden');
            searchContainer.classList.add('hidden');
            resultContainer.classList.add('hidden');
            infoContainer.classList.add('hidden');
        }

        // Отображение интерфейса поиска
        function showSearchInterface() {
            welcomeContainer.classList.add('hidden');
            searchContainer.classList.remove('hidden');
            infoContainer.classList.add('hidden');
        }

        // Отображение информации о приложении
        function showInfoSection() {
            // Персонализируем информацию с использованием имени пользователя
            const personalizeName = userData.name || "пользователь";
            
            infoContent.innerHTML = `
                <p>Уважаемый(ая) <strong>${personalizeName}</strong>, добро пожаловать в "Стохастический Словарь ИИ"!</p>
                <p>Это образовательное приложение для студентов-лингвистов, изучающих концепцию стохастичности в языке и ее применение в сфере искусственного интеллекта.</p>
                
                <h3>Возможности приложения:</h3>
                <ul>
                    <li><strong>Поиск терминов</strong> - введите термин в поле поиска или воспользуйтесь автодополнением</li>
                    <li><strong>Вероятностные дефиниции</strong> - для каждого термина представлены различные определения с указанием их вероятности</li>
                    <li><strong>Семантические связи</strong> - интерактивный граф показывает связи между терминами и их силу</li>
                    <li><strong>Персонализация</strong> - контент адаптируется под ваше имя (${personalizeName})</li>
                </ul>
                
                <p><em>Важно: все данные в словаре являются предзаданными, учебными и симулированными для демонстрационных целей в области ИИ и лингвистики. Они не претендуют на полноту или абсолютную точность.</em></p>
            `;
            
            searchContainer.classList.remove('hidden');
            infoContainer.classList.remove('hidden');
            resultContainer.classList.add('hidden');
        }

        // Отображение информации о термине
        function displayTermInfo(term) {
            if (!dictionary[term]) return;
            
            const termData = dictionary[term];
            const personalizeName = userData.name || "студент";
            
            // Заголовок термина
            termTitle.textContent = term;
            
            // Вероятностные дефиниции
            definitionsContainer.innerHTML = '';
            termData.definitions.forEach((def, index) => {
                // Персонализируем некоторые определения или примеры
                let personalizedText = def.text;
                let personalizedExample = def.examples[0];
                
                // Персонализируем случайным образом
                if (index === Math.floor(Math.random() * termData.definitions.length)) {
                    const nameWords = personalizeName.split(' ');
                    if (nameWords.length >= 1) {
                        const randomWord = Math.random() < 0.5 ? "объяснил(а)" : "определил(а)";
                        personalizedText = `Как ${nameWords[0]} ${randomWord}, ${personalizedText.charAt(0).toLowerCase() + personalizedText.slice(1)}`;
                    }
                }
                
                const defElement = document.createElement('div');
                defElement.className = 'definition';
                defElement.innerHTML = `
                    <p>${personalizedText}</p>
                    <div class="probability-label">Вероятность: ${(def.probability * 100).toFixed(1)}%</div>
                    <div class="probability-bar" style="width: ${def.probability * 100}%"></div>
                    <div class="example">${personalizedExample}</div>
                `;
                definitionsContainer.appendChild(defElement);
            });
            
            // Рендерим граф связей
            renderGraph(term, termData.connections);
            
            // Показываем результат
            resultContainer.classList.remove('hidden');
        }

        // Рендеринг графа связей с помощью D3.js
        function renderGraph(centralTerm, connections) {
            // Очищаем контейнер
            d3.select("#graphContainer").selectAll("*").remove();
            
            // Размеры графа
            const width = graphContainer.clientWidth;
            const height = graphContainer.clientHeight;
            
            // Создаем SVG
            const svg = d3.select("#graphContainer")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Подготавливаем данные для графа
            const nodes = [
                { id: centralTerm, central: true }
            ];
            
            // Добавляем связанные термины
            connections.forEach(conn => {
                nodes.push({ id: conn.word, type: conn.type });
            });
            
            // Создаем связи
            const links = connections.map(conn => ({
                source: centralTerm,
                target: conn.word,
                weight: conn.weight,
                type: conn.type
            }));
            
            // Создаем симуляцию с силами
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2));
            
            // Рисуем связи
            const link = svg.append("g")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke", getComputedStyle(document.documentElement).getPropertyValue('--graph-link-color'))
                .attr("stroke-width", d => d.weight * 5)
                .attr("stroke-opacity", 0.6);
            
            // Рисуем узлы
            const node = svg.append("g")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // Круги для узлов
            node.append("circle")
                .attr("r", d => d.central ? 25 : 20)
                .attr("fill", d => d.central ? 
                    getComputedStyle(document.documentElement).getPropertyValue('--primary-color') : 
                    getComputedStyle(document.documentElement).getPropertyValue('--graph-node-color'));
            
            // Текстовые метки
            node.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .attr("fill", "white")
                .text(d => {
                    // Для длинных слов показываем только часть
                    if (d.id.length > 10) return d.id.substring(0, 8) + "...";
                    return d.id;
                })
                .style("font-size", "12px");
            
            // Добавляем тип связи как подпись на линиях
            svg.append("g")
                .selectAll("text")
                .data(links)
                .enter().append("text")
                .attr("text-anchor", "middle")
                .attr("dy", -5)
                .text(d => d.type)
                .style("font-size", "10px")
                .attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
            
            // Обновление позиций при каждом тике симуляции
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node.attr("transform", d => `translate(${d.x},${d.y})`);
                
                // Обновляем позицию подписей на линиях
                svg.selectAll("text")
                    .filter(function() {
                        return this.parentNode.tagName === "g" && 
                               this.previousSibling === null;
                    })
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
            });
            
            // Функции для перетаскивания узлов
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Переключение темы
        function toggleTheme() {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(currentTheme);
            localStorage.setItem('stochasticDictionaryTheme', currentTheme);
        }

        // Применение темы
        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            themeToggle.textContent = theme === 'light' ? '☀️' : '🌙';
        }

        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>