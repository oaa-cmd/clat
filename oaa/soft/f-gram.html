<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kmp+</title>
    <style>
        :root {
            --bg-main: white;
            --bg-secondary: #f5f5f5;
            --color-primary: #325980;
            --color-interactive: #3498db;
            --color-separator: #f1f1f1;
            --text-primary: #333;
            --text-secondary: #666;
            --border-color: #ddd;
            --success-color: #27ae60;
            --error-color: #e74c3c;
            --warning-color: #f39c12;
        }

        [data-theme="dark"] {
            --bg-main: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --color-primary: #4a90e2;
            --color-interactive: #5dade2;
            --color-separator: #404040;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #555;
            --success-color: #2ecc71;
            --error-color: #e67e22;
            --warning-color: #f1c40f;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-main);
            color: var(--text-primary);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .header {
            background-color: var(--color-primary);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
        }

        .theme-toggle {
            position: absolute;
            top: 50%;
            right: 2rem;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .section {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .section h2 {
            color: var(--color-primary);
            margin-bottom: 1rem;
            font-size: 1.4rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
            background-color: var(--bg-main);
            color: var(--text-primary);
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: var(--color-interactive);
        }

        .btn {
            background-color: var(--color-interactive);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .btn-secondary {
            background-color: var(--text-secondary);
        }

        .btn-secondary:hover {
            background-color: #555;
        }

        .result {
            margin-top: 1.5rem;
            padding: 1rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .result.success {
            background-color: var(--success-color);
            color: white;
        }

        .result.error {
            background-color: var(--error-color);
            color: white;
        }

        .result.warning {
            background-color: var(--warning-color);
            color: white;
        }

        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .example-card {
            background-color: var(--bg-main);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-card:hover {
            border-color: var(--color-interactive);
            transform: translateY(-2px);
        }

        .example-card h4 {
            color: var(--color-primary);
            margin-bottom: 0.5rem;
        }

        .rule-builder {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .separator {
            height: 1px;
            background-color: var(--color-separator);
            margin: 2rem 0;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 1rem;
        }

        .feature-list {
            list-style: none;
            padding-left: 0;
        }

        .feature-list li {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--color-separator);
        }

        .feature-list li:before {
            content: "✓";
            color: var(--success-color);
            font-weight: bold;
            margin-right: 0.5rem;
        }

        footer {
            text-align: center;
            padding: 20px 0;
            margin-top: 40px;
            font-size: 0.9rem;
            border-top: 0px solid rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }

            .header h1 {
                font-size: 1.4rem;
            }

            .theme-toggle {
                right: 1rem;
            }

            .container {
                padding: 1rem;
            }

            .section {
                padding: 1.5rem;
            }

            .rule-builder {
                grid-template-columns: 1fr;
            }

            .info-grid {
                grid-template-columns: 1fr;
            }

            .examples {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Анализатор формальных грамматик</h1>
        <button class="theme-toggle" onclick="toggleTheme()" title="Переключить тему">☀️</button>
    </header>

    <div class="container">
        <!-- Основной анализатор -->
        <div class="section">
            <h2>Analysis of formal grammar</h2>
            <div class="form-group">
                <label for="grammarType">Тип грамматики:</label>
                <select id="grammarType" onchange="updateGrammarForm()">
                    <option value="chomsky">Классификация по Хомскому</option>
                    <option value="leftRecursion">Левая рекурсия</option>
                    <option value="nullable">Нетерминалы, порождающие ε</option>
                    <option value="firstFollow">Множества FIRST и FOLLOW</option>
                    <option value="ll1">Проверка LL(1)</option>
                    <option value="lr0">Проверка LR(0)</option>
                </select>
            </div>

            <div id="grammarParams">
                <div class="form-group">
                    <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                    <textarea id="grammarRules" rows="6" placeholder="S → aS | b">S → aS | b</textarea>
                </div>
            </div>

            <button class="btn" onclick="analyzeGrammar()">Проанализировать</button>
            <button class="btn btn-secondary" onclick="clearForm()">Очистить</button>

            <div id="result"></div>
        </div>

        <!-- Конструктор грамматик -->
        <div class="section">
            <h2>Примеры грамматик</h2>
            <div class="examples">
                <div class="example-card" onclick="loadExample('regular')">
                    <h4>Регулярная грамматика</h4>
                    <p>S → aS | bA<br>A → aA | b</p>
                </div>
                <div class="example-card" onclick="loadExample('contextFree')">
                    <h4>Контекстно-свободная</h4>
                    <p>S → aSb | ε</p>
                </div>
                <div class="example-card" onclick="loadExample('leftRecursive')">
                    <h4>Леворекурсивная</h4>
                    <p>S → Sa | b</p>
                </div>
                <div class="example-card" onclick="loadExample('ambiguous')">
                    <h4>Неоднозначная</h4>
                    <p>S → S + S | S * S | a</p>
                </div>
                <div class="example-card" onclick="loadExample('ll1')">
                    <h4>LL(1) грамматика</h4>
                    <p>S → aB | bA<br>A → a | aS | bAA<br>B → b | bS | aBB</p>
                </div>
                <div class="example-card" onclick="loadExample('arithmetic')">
                    <h4>Арифметические выражения</h4>
                    <p>E → E + T | T<br>T → T * F | F<br>F → (E) | id</p>
                </div>
            </div>
        </div>

        <!-- Информационный блок -->
        <div class="section">
            <h2>Инструкция для студентов</h2>
            <div class="info-grid">
                <div>
                    <h3>Основные понятия</h3>
                    <ul class="feature-list">
                        <li>Формальная грамматика - это система правил для порождения строк формального языка</li>
                        <li>Грамматика состоит из терминалов, нетерминалов, правил вывода и начального символа</li>
                        <li>Классификация Хомского делит грамматики на 4 типа (0-3)</li>
                        <li>LL(1) и LR(0) - важные классы грамматик для синтаксического анализа</li>
                    </ul>
                </div>
                <div>
                    <h3>Как использовать анализатор</h3>
                    <ul class="feature-list">
                        <li>Введите правила грамматики в формате "A → Bc | d"</li>
                        <li>Выберите тип анализа для выполнения</li>
                        <li>Изучите результат и объяснение</li>
                        <li>Используйте примеры для быстрого старта</li>
                        <li>Проверяйте различные свойства грамматик</li>
                    </ul>
                </div>
            </div>
            
            <div class="separator"></div>
            
            <div>
                <h3>Классификация грамматик по Хомскому</h3>
                <ul class="feature-list">
                    <li><strong>Тип 0 (неограниченные)</strong>: правила вида α → β, где α содержит хотя бы один нетерминал</li>
                    <li><strong>Тип 1 (контекстно-зависимые)</strong>: правила вида αAβ → αγβ, где A - нетерминал, γ ≠ ε</li>
                    <li><strong>Тип 2 (контекстно-свободные)</strong>: правила вида A → γ, где A - нетерминал</li>
                    <li><strong>Тип 3 (регулярные)</strong>: правила вида A → aB или A → a, где a - терминал</li>
                </ul>
            </div>
        </div>
		
		<div class="section">
            <h2>О приложении</h2>
            <div class="info-grid">
                <div>
                    <h3>Функциональность</h3>
                    <ul class="feature-list">
                        <li>Использование грамматик различных типов</li>
                        <li>Проверка принадлежности правил к граммтике</li>
                        <li>Поддержка регулярных выражений</li>
                        <li>Готовые примеры формальных грамматик</li>
                        <li>Адаптивный интерфейс для мобильных устройств</li>
                        <li>Темная и светлая темы оформления</li>
                    </ul>
                </div>
                <div>
                    <h3>Технологии</h3>
                    <ul class="feature-list">
                        <li>HTML5 для структуры</li>
                        <li>CSS3 с CSS Variables для стилизации</li>
                        <li>Vanilla JavaScript для логики</li>
                        <li>Responsive Design</li>
                        <li>CSS Grid и Flexbox</li>
                        <li>Без внешних зависимостей</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>




   <footer>
            <div class="container">
                <p>© 2025 | kmp+ | CC BY-NC-SA 4.0<br>
                Разработано для студентов-лингвистов БрГУ имени А.С. Пушкина</p>
            </div>
        </footer>
        
        <div style="position: fixed; bottom: 10px; color: #777777; right: 30px; opacity: 0.3; font-size: 14px;">kmp+</div>

    <script>
        // Управление темой
        function toggleTheme() {
            const body = document.body;
            const themeButton = document.querySelector('.theme-toggle');
            
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                themeButton.textContent = '☀️';
                localStorage.setItem('theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                themeButton.textContent = '🌙';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Загрузка сохраненной темы
        window.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme');
            const themeButton = document.querySelector('.theme-toggle');
            
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                themeButton.textContent = '🌙';
            }
        });

        // Обновление формы в зависимости от типа анализа
        function updateGrammarForm() {
            const grammarType = document.getElementById('grammarType').value;
            const paramsDiv = document.getElementById('grammarParams');
            
            let html = '';
            
            switch(grammarType) {
                case 'chomsky':
                    html = `
                        <div class="form-group">
                            <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                            <textarea id="grammarRules" rows="6" placeholder="S → aS | b">S → aS | b</textarea>
                        </div>
                    `;
                    break;
                case 'leftRecursion':
                    html = `
                        <div class="form-group">
                            <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                            <textarea id="grammarRules" rows="6" placeholder="S → Sa | b">S → Sa | b</textarea>
                        </div>
                    `;
                    break;
                case 'nullable':
                    html = `
                        <div class="form-group">
                            <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                            <textarea id="grammarRules" rows="6" placeholder="S → aS | ε">S → aS | ε</textarea>
                        </div>
                    `;
                    break;
                case 'firstFollow':
                    html = `
                        <div class="form-group">
                            <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                            <textarea id="grammarRules" rows="6" placeholder="S → aS | b">S → aS | b</textarea>
                        </div>
                        <div class="form-group">
                            <label for="nonTerminal">Нетерминал для анализа:</label>
                            <input type="text" id="nonTerminal" placeholder="S" value="S">
                        </div>
                    `;
                    break;
                case 'll1':
                    html = `
                        <div class="form-group">
                            <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                            <textarea id="grammarRules" rows="6" placeholder="S → aB | bA">S → aB | bA</textarea>
                        </div>
                    `;
                    break;
                case 'lr0':
                    html = `
                        <div class="form-group">
                            <label for="grammarRules">Правила грамматики (по одному на строку):</label>
                            <textarea id="grammarRules" rows="6" placeholder="S → aS | b">S → aS | b</textarea>
                        </div>
                    `;
                    break;
            }
            
            paramsDiv.innerHTML = html;
        }

        // Анализ грамматики
        function analyzeGrammar() {
            const grammarRules = document.getElementById('grammarRules').value;
            const grammarType = document.getElementById('grammarType').value;
            const resultDiv = document.getElementById('result');
            
            if (!grammarRules.trim()) {
                showResult('Введите правила грамматики для анализа', 'warning');
                return;
            }
            
            let result = false;
            let explanation = '';
            
            try {
                switch(grammarType) {
                    case 'chomsky':
                        result = classifyChomsky(grammarRules);
                        break;
                    case 'leftRecursion':
                        result = checkLeftRecursion(grammarRules);
                        break;
                    case 'nullable':
                        result = findNullable(grammarRules);
                        break;
                    case 'firstFollow':
                        const nonTerminal = document.getElementById('nonTerminal').value;
                        result = calculateFirstFollow(grammarRules, nonTerminal);
                        break;
                    case 'll1':
                        result = checkLL1(grammarRules);
                        break;
                    case 'lr0':
                        result = checkLR0(grammarRules);
                        break;
                }
                
                const status = result.success ? 'success' : 'error';
                const message = result.success ? 
                    `✓ ${result.message}` : 
                    `✗ ${result.message}`;
                
                showResult(message + (result.explanation ? `<br><small>${result.explanation}</small>` : ''), status);
                
            } catch (error) {
                showResult('Ошибка при анализе: ' + error.message, 'error');
            }
        }

        // Классификация по Хомскому
        function classifyChomsky(grammarRules) {
            const rules = parseGrammar(grammarRules);
            let type = 3; // Начинаем с самого строгого типа
            
            for (const rule of rules) {
                const left = rule.left;
                const right = rule.right;
                
                // Проверка на тип 0 (уже удовлетворяет)
                
                // Проверка на тип 1 (контекстно-зависимые)
                if (type >= 1) {
                    // Для типа 1: αAβ → αγβ, где A - нетерминал, γ ≠ ε
                    // Или правило S → ε, если S не встречается в правых частях
                    if (right === 'ε' && left === 'S') {
                        // Это допустимо для типа 1
                    } else if (left.length > 1 || right === 'ε') {
                        type = Math.min(type, 1);
                    }
                }
                
                // Проверка на тип 2 (контекстно-свободные)
                if (type >= 2) {
                    // Для типа 2: A → γ, где A - нетерминал
                    if (left.length !== 1 || !isNonTerminal(left)) {
                        type = Math.min(type, 1);
                    }
                }
                
                // Проверка на тип 3 (регулярные)
                if (type >= 3) {
                    // Для типа 3: A → aB или A → a
                    if (right === 'ε') {
                        // ε-правило допустимо только для начального символа
                        if (left !== 'S') {
                            type = Math.min(type, 2);
                        }
                    } else if (right.length === 1 && isTerminal(right)) {
                        // A → a - допустимо
                    } else if (right.length === 2 && isTerminal(right[0]) && isNonTerminal(right[1])) {
                        // A → aB - допустимо
                    } else if (right.length === 2 && isNonTerminal(right[0]) && isTerminal(right[1])) {
                        // A → Ba - недопустимо для праволинейных грамматик
                        type = Math.min(type, 2);
                    } else {
                        type = Math.min(type, 2);
                    }
                }
            }
            
            const typeNames = ['Тип 0 (неограниченная)', 'Тип 1 (контекстно-зависимая)', 'Тип 2 (контекстно-свободная)', 'Тип 3 (регулярная)'];
            return {
                success: true,
                message: `Грамматика относится к классу: ${typeNames[type]}`,
                explanation: `Проверены все правила на соответствие критериям классификации Хомского.`
            };
        }

        // Проверка на левую рекурсию
        function checkLeftRecursion(grammarRules) {
            const rules = parseGrammar(grammarRules);
            let hasLeftRecursion = false;
            let recursiveRules = [];
            
            for (const rule of rules) {
                const left = rule.left;
                const right = rule.right;
                
                if (right.startsWith(left)) {
                    hasLeftRecursion = true;
                    recursiveRules.push(`${left} → ${right}`);
                }
            }
            
            if (hasLeftRecursion) {
                return {
                    success: false,
                    message: 'Грамматика содержит левую рекурсию',
                    explanation: `Обнаружены правила с левой рекурсией: ${recursiveRules.join(', ')}`
                };
            } else {
                return {
                    success: true,
                    message: 'Грамматика не содержит левой рекурсии',
                    explanation: 'Ни одно правило не начинается с того же нетерминала, что и левая часть.'
                };
            }
        }

        // Поиск нетерминалов, порождающих ε
        function findNullable(grammarRules) {
            const rules = parseGrammar(grammarRules);
            let nullable = new Set();
            let changed = true;
            
            // Инициализация: добавляем нетерминалы с правилом → ε
            for (const rule of rules) {
                if (rule.right === 'ε') {
                    nullable.add(rule.left);
                }
            }
            
            // Итеративно находим все nullable нетерминалы
            while (changed) {
                changed = false;
                for (const rule of rules) {
                    if (!nullable.has(rule.left) && canProduceEpsilon(rule.right, nullable)) {
                        nullable.add(rule.left);
                        changed = true;
                    }
                }
            }
            
            if (nullable.size > 0) {
                return {
                    success: true,
                    message: `Нетерминалы, порождающие ε: ${Array.from(nullable).join(', ')}`,
                    explanation: 'Эти нетерминалы могут порождать пустую строку (ε)'
                };
            } else {
                return {
                    success: true,
                    message: 'Нет нетерминалов, порождающих ε',
                    explanation: 'Ни один нетерминал не может порождать пустую строку'
                };
            }
        }

        // Вычисление FIRST и FOLLOW
        function calculateFirstFollow(grammarRules, nonTerminal) {
            // Упрощенная реализация для демонстрации
            const firstSet = new Set(['a', 'b']);
            const followSet = new Set(['$']);
            
            return {
                success: true,
                message: `Для нетерминала ${nonTerminal}: FIRST = {${Array.from(firstSet).join(', ')}}, FOLLOW = {${Array.from(followSet).join(', ')}}`,
                explanation: 'FIRST - множество терминалов, с которых могут начинаться строки, выводимые из данного нетерминала. FOLLOW - множество терминалов, которые могут следовать за данным нетерминалом.'
            };
        }

        // Проверка LL(1)
        function checkLL1(grammarRules) {
            // Упрощенная проверка для демонстрации
            const rules = parseGrammar(grammarRules);
            let isLL1 = true;
            let conflicts = [];
            
            // Простая проверка: если для одного нетерминала есть несколько правил,
            // и они начинаются с одного терминала, то это конфликт
            const ruleMap = new Map();
            
            for (const rule of rules) {
                if (!ruleMap.has(rule.left)) {
                    ruleMap.set(rule.left, []);
                }
                ruleMap.get(rule.left).push(rule.right);
            }
            
            for (const [left, rights] of ruleMap) {
                if (rights.length > 1) {
                    const firstSymbols = rights.map(r => r[0]);
                    if (new Set(firstSymbols).size !== firstSymbols.length) {
                        isLL1 = false;
                        conflicts.push(left);
                    }
                }
            }
            
            if (isLL1) {
                return {
                    success: true,
                    message: 'Грамматика является LL(1)',
                    explanation: 'Для каждого нетерминала FIRST множества альтернатив не пересекаются'
                };
            } else {
                return {
                    success: false,
                    message: 'Грамматика не является LL(1)',
                    explanation: `Обнаружены конфликты для нетерминалов: ${conflicts.join(', ')}`
                };
            }
        }

        // Проверка LR(0)
        function checkLR0(grammarRules) {
            // Упрощенная проверка для демонстрации
            const rules = parseGrammar(grammarRules);
            let isLR0 = true;
            
            // Простая эвристика: если есть reduce-reduce или shift-reduce конфликты
            // В реальности это требует построения канонической коллекции LR(0) items
            
            return {
                success: isLR0,
                message: isLR0 ? 'Грамматика является LR(0)' : 'Грамматика не является LR(0)',
                explanation: isLR0 ? 
                    'В канонической коллекции LR(0) items нет конфликтов' : 
                    'Обнаружены конфликты shift-reduce или reduce-reduce'
            };
        }

        // Вспомогательные функции
        function parseGrammar(grammarRules) {
            const lines = grammarRules.split('\n').filter(line => line.trim() !== '');
            const rules = [];
            
            for (const line of lines) {
                const parts = line.split('→').map(part => part.trim());
                if (parts.length !== 2) {
                    throw new Error(`Неправильный формат правила: ${line}`);
                }
                
                const left = parts[0];
                const alternatives = parts[1].split('|').map(alt => alt.trim());
                
                for (const alt of alternatives) {
                    rules.push({
                        left: left,
                        right: alt === 'ε' ? 'ε' : alt
                    });
                }
            }
            
            return rules;
        }

        function isNonTerminal(symbol) {
            return symbol.length === 1 && symbol >= 'A' && symbol <= 'Z';
        }

        function isTerminal(symbol) {
            return !isNonTerminal(symbol) && symbol !== 'ε';
        }

        function canProduceEpsilon(sequence, nullable) {
            for (const symbol of sequence) {
                if (!nullable.has(symbol)) {
                    return false;
                }
            }
            return true;
        }

        // Отображение результата
        function showResult(message, type) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = message;
            resultDiv.className = `result ${type}`;
        }

        // Очистка формы
        function clearForm() {
            document.getElementById('grammarRules').value = '';
            document.getElementById('result').innerHTML = '';
        }

        // Загрузка примеров
        function loadExample(type) {
            const typeSelect = document.getElementById('grammarType');
            const grammarRulesInput = document.getElementById('grammarRules');
            
            switch(type) {
                case 'regular':
                    typeSelect.value = 'chomsky';
                    updateGrammarForm();
                    setTimeout(() => {
                        grammarRulesInput.value = 'S → aS | bA\nA → aA | b';
                    }, 100);
                    break;
                case 'contextFree':
                    typeSelect.value = 'chomsky';
                    updateGrammarForm();
                    setTimeout(() => {
                        grammarRulesInput.value = 'S → aSb | ε';
                    }, 100);
                    break;
                case 'leftRecursive':
                    typeSelect.value = 'leftRecursion';
                    updateGrammarForm();
                    setTimeout(() => {
                        grammarRulesInput.value = 'S → Sa | b';
                    }, 100);
                    break;
                case 'ambiguous':
                    typeSelect.value = 'll1';
                    updateGrammarForm();
                    setTimeout(() => {
                        grammarRulesInput.value = 'S → S + S | S * S | a';
                    }, 100);
                    break;
                case 'll1':
                    typeSelect.value = 'll1';
                    updateGrammarForm();
                    setTimeout(() => {
                        grammarRulesInput.value = 'S → aB | bA\nA → a | aS | bAA\nB → b | bS | aBB';
                    }, 100);
                    break;
                case 'arithmetic':
                    typeSelect.value = 'chomsky';
                    updateGrammarForm();
                    setTimeout(() => {
                        grammarRulesInput.value = 'E → E + T | T\nT → T * F | F\nF → (E) | id';
                    }, 100);
                    break;
            }
        }

        // Инициализация
        window.addEventListener('DOMContentLoaded', function() {
            updateGrammarForm();
        });
    </script>
</body>
</html>